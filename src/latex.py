"""Module for running LaTex (``pdflatex``) for ``mapmuts`` package..

This module contains functions that run ``pdflatex``, if it can be found in
the current search path. This can be assessed using `PdflatexAvailable`.
If `PdflatexAvailable() == False`, none of the other functions in this
module will run.

Written by Jesse Bloom.


List of functions
---------------------
`PdflatexAvailable` : is ``pdflatex`` available?

`MakeAlignmentsSummary` : uses ``pdflatex`` to make a summary of the plots
generated by `mapmuts.main.MakeAlignmentsPlots`.

`MakeParseSummary` : uses ``pdflatex`` to make a summary of the plots
generated by `mapmuts.main.MakeParseNTCodonCountsPlots`.


Documentation for functions
----------------------------
Documentation for individual functions is provided in their definitions below.
"""


import subprocess
import os
import time
import tempfile


def PdflatexAvailable():
    """Tests of ``pdflatex`` can be accessed in the current path.
    
    If ``pdflatex`` is not available, returns *False*.
    
    Otherwise, returns a non-empty string giving the version number
    of ``pdflatex``.
    """
    try:
        sout = tempfile.TemporaryFile()
        code = subprocess.call(['pdflatex', '--version'], stdout=sout)
        if code == 0:
            sout.seek(0)
            version = sout.read()
            sout.close()
            if not bool(version):
                version = 'version not available'
            return version
        else:
            sout.close()
            return False
    except OSError:
        return False


def Runpdflatex(infile):
    """Runs ``pdflatex`` on a ``*.tex`` file.

    This function can only be run if `PdflatexAvailable()`.

    `infile` : name of a ``*.tex`` file on which we run ``pdflatex``
    twice to generate the output ``*.pdf`` file from `infile`. If
    a PDF file with this basename already exists, it is deleted
    before running ``pdflatex``.
    """
    if not PdflatexAvailable():
        raise OSError("pdflatex not available")
    (base, ext) = os.path.splitext(infile)
    if ext != '.tex':
        raise ValueError("infile %s does not end in .tex" % infile)
    outfile = '%s.pdf' % base
    if os.path.isfile(outfile):
        os.remove(outfile)
    if not os.path.isfile(infile):
        raise IOError("Cannot fine infile of %s" % infile)
    for runs in range(2):
        (output, errors) = subprocess.Popen(['pdflatex', '-halt-on-error', infile],\
                stdout=subprocess.PIPE).communicate()
        if errors:
            raise IOError("pdflatex failed as the following was"\
                    + 'written to stderr:\n%s' % errors)
    if not os.path.isfile(outfile):
        raise IOError("RunpdfLatex failed to produce output file of %s" % outfile)


def MakeAlignmentsSummary(outfileprefix, minq, maxn, minoverlap,\
        maxrm, maxa1m, maxa2m, maxgenem, title):
    """Makes PDF summary of `mapmuts.main.MakeAlignments` output.

    This function assembles the plots created by
    `mapmuts.main.MakeAlignmentsPlots` into a single LaTex file, which is
    then compiled using ``pdflatex``. The resulting output PDF will contain
    all of the plots created by `mapmuts.main.MakeAlignmentsPlots`, plus
    information about the alignment settings. This function requires the
    plots created by `mapmuts.main.MakeAlignmentsPlots` to already be
    created.

    The first nine calling arguments have the exact same meaning as in
    `mapmuts.main.MakeAlignmentsPlots`. 
    
    `title` specifies a string that is printed as the summary title.

    The final output file generated will have the name 
    ``"%s_makealignments_summary.pdf" % outfileprefix``. Various other LaTex files (such as
    ``*.aux`` and ``*.tex`` files) of the same base name will also be created.

    This function will raise an exception if `PdflatexAvailable() ==
    False`, since in that case the Latex summary cannot be created.
    """
    if not PdflatexAvailable():
        raise OSError("Cannot run pdflatex")
    for plotname in ['alignmentstatistics', 'insertlengths',\
            'R1mismatches', 'R2mismatches']:

        fname = "%s_%s.pdf" % (outfileprefix, plotname)
        if not os.path.isfile(fname):
            raise IOError("Could not find plotfile %s" % fname)
    try:
        texfile = '%s_makealignments_summary.tex' % outfileprefix
        f = open(texfile, 'w')
        f.write('\documentclass[10pt,letterpaper]{article}\n' +\
                '\usepackage{graphicx}\n\usepackage[margin=0.8in]{geometry}'\
                + '\n\pagestyle{empty}\n\n\\begin{document}\n')
        fname = '%s_alignmentstatistics.pdf' % outfileprefix
        f.write('\centerline{\Large \\bf %s}\n' % title.replace('_', '\_'))
        f.write('\\vspace{0.3in}\n\n')
        f.write('\center{\\begin{minipage}{4.3in}\n')
        f.write('\centerline{\includegraphics[width=4in]{%s}}\n' % fname)
        f.write('\\vspace{0.3in}\n\n')
        fname = '%s_insertlengths.pdf' % outfileprefix
        f.write('\centerline{\includegraphics[width=4in]{%s}}\n' % fname)
        f.write('\end{minipage}\n\\begin{minipage}{2.1in}\n')
        f.write('\n\underline{\large \\bf Alignment settings}\n')
        f.write('\\begin{description}\n')
        f.write('\item[minq = %.1f]\n' % minq) 
        f.write('Both reads must have mean Q-value $\ge$ this.\n')
        f.write('\item[maxn = %d]\n' % maxn)
        f.write('Number of N/n nucleotides must be $\le$ this for'\
                + ' each read.\n')
        f.write('\item[minoverlap = %d]\n' % minoverlap)
        f.write('Overlap between paired reads must be $\ge$ this.\n')
        f.write('\item[maxrm = %d]\n' % maxrm)
        f.write('Number of mismatches in paired reads overlap'\
                + ' must be $\le$ this.\n')
        f.write('\item[maxa1m = %d]\n' % maxa1m)
        f.write('Number of mismatches between R1 and its adaptor must'\
                + ' be $\le$ this.\n')
        f.write('\item[maxa2m = %d]\n' % maxa2m)
        f.write('Number of mismatches between R2 and its adaptor must'\
                + ' be $\le$ this.\n')
        f.write('\item[maxgenem = %d]\n' % maxgenem)
        f.write('Neither read can have $>$ than this many mismatches'\
                + ' with target sequence after trimming adaptor.\n')
        f.write('\end{description}\n')
        f.write('\end{minipage}}\n')
        f.write('\\vspace{0.3in}\n\n')
        fname1 = '%s_R1mismatches.pdf' % outfileprefix
        fname2 = '%s_R2mismatches.pdf' % outfileprefix
        f.write('\centerline{\includegraphics[width=3in]{%s}' % fname1\
                + '\hspace{0.3in}\includegraphics[width=3in]{%s}}' % fname2)
        f.write('\n\end{document}\n')
    finally:
        f.close()
    Runpdflatex(texfile)


def MakeParseSummary(outfileprefix, r1exclude, r2exclude, title):
    """Makes PDF summary of `mapmuts.main.ParseNTCodonCounts` output.

    This function assembles the plots created by
    `mapmuts.main.ParseNTCodonCountsPlots` into a single LaTex file, which is
    then compiled using ``pdflatex``. The resulting output PDF will contain
    all of the plots created by `mapmuts.main.ParseNTCodonCountsPlots`, plus
    information about the alignment settings. This function requires the
    plots created by `mapmuts.main.ParseNTCodonCountsPlots` to already be
    created.

    The first three calling arguments have the exact same meaning as in
    `mapmuts.main.MakeAlignmentsPlots`. 
    
    `title` specifies a string that is printed as the summary title.

    The final output file generated will have the name 
    ``"%s_parsesummary.pdf" % outfileprefix``. Various other LaTex files (such
    as ``*.aux`` and ``*.tex`` files) of the same base name will also be created.

    This function will raise an exception if `PdflatexAvailable() ==
    False`, since in that case the Latex summary cannot be created.
    """
    if not PdflatexAvailable():
        raise OSError("Cannot run pdflatex")
    for plotname in ['codondepth', 'syn-ns-dist']:
        fname = "%s_%s.pdf" % (outfileprefix, plotname)
        if not os.path.isfile(fname):
            raise IOError("Could not find plotfile %s" % fname)
    try:
        texfile = '%s_parsesummary.tex' % outfileprefix
        f = open(texfile, 'w')
        f.write('\documentclass[10pt,letterpaper]{article}\n' +\
                '\usepackage{graphicx}\n\usepackage[margin=0.8in]{geometry}'\
                + '\n\pagestyle{empty}\n\n\\begin{document}\n')
        f.write('\centerline{\Large \\bf %s}\n' % title.replace('_', '\_'))
        f.write('\\vspace{0.1in}\n\n')
        fname = '%s_codondepth.pdf' % outfileprefix
        f.write('\centerline{\includegraphics[width=5in]{%s}}\n' % fname)
        f.write('\\vspace{0.1in}\n\n')
        fname = '%s_syn-ns-dist.pdf' % outfileprefix
        f.write('\centerline{\includegraphics[width=5in]{%s}}\n' % fname)
        f.write('\\vspace{0.1in}\n\n')
        fname = '%s_nmutspercodon-dist.pdf' % outfileprefix
        f.write('\centerline{\includegraphics[width=5in]{%s}}\n' % fname)
        f.write('\\vspace{0.1in}\n\n')
        f.write('Fractions calculated'\
                + ' using only positions called to the'\
                + ' same identity by both paired reads. ')
        for (read, exclude) in [('R1', r1exclude), ('R2', r2exclude)]:
            if not exclude:
                f.write(' No positions were excluded for %s. ' % read)
            else:
                f.write(' Excluded positions for %s were %s. ' % (read, ', '.join([str(i) for i in exclude])))
            f.write('\n')
        f.write('\n\end{document}\n')
    finally:
        f.close()
    Runpdflatex(texfile)



# test with doctest
if __name__ == '__main__':
    import doctest
    doctest.testmod()
